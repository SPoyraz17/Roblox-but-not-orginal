<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROBLOX Hibrit Platform - 3D</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> 
    
    <style>
        /* --- CSS STÄ°LLERÄ° --- */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            background-color: #f0f0f0;
            color: #333;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
        }

        .screen {
            width: 100%;
            max-width: 1200px; 
            margin: 20px auto;
            display: none;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            border-radius: 8px;
            padding: 20px;
        }

        /* Ana Ekran */
        .game-tile {
            border: 1px solid #ccc;
            padding: 15px;
            margin: 10px;
            cursor: pointer;
            text-align: center;
            border-radius: 5px;
            transition: background-color 0.3s;
            width: 300px;
        }
        .game-tile:hover { background-color: #e0f7ff; }

        /* Studio & Game Canvas Container */
        .canvas-container {
            display: flex;
            position: relative;
        }

        #studioCanvasContainer, #gameCanvasContainer {
            width: 900px;
            height: 600px;
            border: 3px solid #333;
        }
        
        #studioToolbar {
            padding: 10px;
            background-color: #eee;
            border-radius: 5px;
            margin-left: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 250px;
            height: 600px;
        }

        button {
            padding: 10px 15px;
            background-color: #007acc;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        button:hover { background-color: #005f99; }
        
        #studioCanvasContainer {
             cursor: default;
        }

        #selectedBlockInfo {
            font-weight: bold;
            color: #333;
            padding: 5px;
            border-bottom: 1px solid #ccc;
        }
    </style>
</head>
<body>

    <div id="homeScreen" class="screen" style="display: block;"> 
        <h1>ROBLOX Hibrit Platform - Ana Ekran (3D)</h1>
        <p>Projelerinizi seÃ§in:</p>
        <div style="display: flex; flex-wrap: wrap;">
            <div class="game-tile" onclick="loadAndShowStudio();">
                <h2>ğŸ–Œï¸ 3D Studio (Harita OluÅŸtur)</h2>
                <p>**N** (TaÅŸÄ±ma), **B** (BoyutlandÄ±rma), **O** (DÃ¶ndÃ¼rme) modlarÄ± ile Ã§alÄ±ÅŸÄ±n.</p>
            </div>
            <div class="game-tile" onclick="loadAndStartGame();">
                <h2>â–¶ï¸ Parkur DÃ¼nyasÄ± (Oyna - 3D)</h2>
                <p>**WASD, Space** tuÅŸlarÄ± ile haritada hareket edin.</p>
            </div>
        </div>
    </div>

    <div id="studioScreen" class="screen">
        <h1 style="color: #00a000;">Roblox 3D Studio</h1>
        <button onclick="stopStudioLoop(); showScreen('homeScreen');" style="margin-bottom: 10px;">ğŸ  Ana Ekrana DÃ¶n</button>
        
        <div class="canvas-container">
            <div id="studioCanvasContainer">
                </div>
            <div id="studioToolbar">
                <button onclick="addBlock(0, 5, 0);">Yeni Platform Ekle</button>
                <button onclick="saveMapToLocal();" style="background-color: #ffaa00;">ğŸ’¾ HaritayÄ± Kaydet (JSON)</button>
                <button onclick="loadMapFromLocalAndRefresh();">ğŸ”„ KayÄ±tlÄ± HaritayÄ± YÃ¼kle</button>
                <button onclick="clearMap();" style="background-color: #cc0000;">HaritayÄ± Temizle</button>
                
                <p id="selectedBlockInfo">Mod: TaÅŸÄ±ma (N). Blok: Yok</p>

                <div style="border-top: 1px solid #ccc; margin-top: 10px; padding-top: 10px;">
                    <p>Kontroller:</p>
                    <ul>
                        <li>**N:** TaÅŸÄ±ma Modu (OklarÄ± sÃ¼rÃ¼kleyerek eksen boyunca taÅŸÄ±)</li>
                        <li>**B:** BoyutlandÄ±rma Modu (Daireleri sÃ¼rÃ¼kleyerek boyutlandÄ±r)</li>
                        <li>**O:** DÃ¶ndÃ¼rme Modu (Halkalar belirir - GÃ¶rsel)</li>
                        <li>**WASD/QE:** Kamera Hareketi</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <div id="gameScreen" class="screen">
        <h1 style="color: #0000ff;">3D Parkur Oyunu</h1>
        <button onclick="stopGameLoop(); showScreen('homeScreen');" style="margin-bottom: 10px;">ğŸ  Ana Ekrana DÃ¶n</button>
        <div id="gameCanvasContainer">
            </div>
    </div>

    <script>
        // --- TEMEL GLOBAL AYARLAR ---
        const GAME_MAP_KEY = "RobloxMapData3D"; 
        const CANVAS_W = 900;
        const CANVAS_H = 600;
        const HANDLE_SIZE = 0.5; // Handle dairelerinin boyutu
        const ARROW_LENGTH = 8; // Ok iÅŸaretlerinin uzunluÄŸu
        
        // 3D Three.js Sahne DeÄŸiÅŸkenleri
        let mapDataJSON = []; 
        let studioScene, studioCamera, studioRenderer;
        let studioAnimationFrame = null;
        
        // Studio Kontrol DeÄŸiÅŸkenleri
        let keys = {};
        let mouseLook = false; 
        let studioMode = 'move'; // VarsayÄ±lan: TaÅŸÄ±ma
        let selectedMesh = null; // TÄ±klanan ana blok
        let selectedHandle = null; // TÄ±klanan manipÃ¼lasyon aracÄ±
        let transformControlsGroup = null; // Handle'larÄ± tutan grup
        let dragOffset = new THREE.Vector3(); // TaÅŸÄ±ma modunda ofset

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // OYUN Ä°STEMCÄ°SÄ° DEÄÄ°ÅKENLERÄ°
        let gameScene, gameCamera, gameRenderer;
        let gameAnimationFrame = null;
        let playerMesh = null;
        
        // Oyuncu Fizik Parametreleri
        const PLAYER_HEIGHT = 2;
        const PLAYER_RADIUS = 0.5;
        const GRAVITY = 0.08;
        const JUMP_FORCE = 1.0;
        const MOVE_SPEED = 0.1;


        // --- EKRAN VE MOD YÃ–NETÄ°MÄ° ---
        
        function getModeText() {
            switch(studioMode) {
                case 'move': return 'TaÅŸÄ±ma (N)';
                case 'resize': return 'BoyutlandÄ±rma (B)';
                case 'rotate': return 'DÃ¶ndÃ¼rme (O)';
                default: return 'Bilinmiyor';
            }
        }

        function updateToolbarInfo() {
             const blockInfo = selectedMesh ? `Blok ID: ${selectedMesh.userData.id}` : 'Blok: Yok';
             document.getElementById('selectedBlockInfo').textContent = `Mod: ${getModeText()}. ${blockInfo}`;
        }
        
        function showScreen(screenId) {
            const screens = ['homeScreen', 'studioScreen', 'gameScreen'];
            screens.forEach(id => {
                document.getElementById(id).style.display = 'none';
            });
            document.getElementById(screenId).style.display = 'block';
            
            if (screenId === 'studioScreen') {
                updateToolbarInfo();
                startStudioLoop();
            } else {
                stopStudioLoop();
                if(transformControlsGroup) transformControlsGroup.visible = false;
                selectedMesh = null;
                selectedHandle = null;
            }
            
            if (screenId === 'gameScreen') {
                startGameLoop();
            } else {
                stopGameLoop();
            }
        }
        
        function loadAndShowStudio() {
            loadMapFromLocal(); 
            setupStudio3D();    
            createBlocksFromData(studioScene, mapDataJSON, true); 
            showScreen('studioScreen');
        }

        function loadMapFromLocalAndRefresh() {
            if (loadMapFromLocal()) {
                clearScene(studioScene);
                createBlocksFromData(studioScene, mapDataJSON, true);
                selectedMesh = null;
                attachHandles(null);
                updateToolbarInfo();
            }
        }

        function loadAndStartGame() {
            loadMapFromLocal(); 
            setupGame3D(); 
            showScreen('gameScreen');
        }

        // --- JSON / KAYIT Ä°ÅLEMLERÄ° ---

        function saveMapToLocal() {
            const dataToSave = studioScene.children
                .filter(c => c.userData.isBlock)
                .map(p => ({
                    x: p.position.x, y: p.position.y, z: p.position.z,
                    w: p.scale.x, h: p.scale.y, d: p.scale.z
                }));
            
            try {
                const jsonString = JSON.stringify(dataToSave);
                localStorage.setItem(GAME_MAP_KEY, jsonString);
                alert("Harita baÅŸarÄ±yla yerel olarak kaydedildi (JSON)!");
            } catch (e) {
                alert("Hata: Harita kaydedilemedi!");
                console.error(e);
            }
        }

        function loadMapFromLocal() {
            const jsonString = localStorage.getItem(GAME_MAP_KEY);
            
            try {
                if (jsonString) {
                    mapDataJSON = JSON.parse(jsonString);
                } else {
                    mapDataJSON = [{ x: 0, y: -0.5, z: 0, w: 50, h: 1, d: 50 }]; 
                }
                return true;
            } catch (e) {
                alert("Hata: KayÄ±tlÄ± harita bozuk!");
                mapDataJSON = [{ x: 0, y: -0.5, z: 0, w: 50, h: 1, d: 50 }];
                return false;
            }
        }

        function clearMap() {
            clearScene(studioScene);
            addBlock(0, -0.5, 0, 50, 1, 50); 
            saveMapToLocal();
        }

        function clearScene(scene) {
            if (!scene) return;
            const objectsToRemove = scene.children.filter(child => child.userData.isBlock);
            if (scene === studioScene && transformControlsGroup) {
                 while (transformControlsGroup.children.length > 0) {
                    const child = transformControlsGroup.children[0];
                    if (child.isMesh) {
                        child.geometry.dispose();
                        child.material.dispose();
                    }
                    transformControlsGroup.remove(child);
                 }
                 transformControlsGroup.visible = false;
            }
            
            objectsToRemove.forEach(child => {
                if (child.isMesh) {
                    child.geometry.dispose();
                    child.material.dispose();
                }
                scene.remove(child);
            });
        }

        // --- 2. 3D STUDIO KURULUMU VE MANTIÄI ---

        function setupStudio3D() {
            if (studioScene) return; 
            
            studioScene = new THREE.Scene(); 
            studioScene.background = new THREE.Color(0x87ceeb); 

            studioCamera = new THREE.PerspectiveCamera(75, CANVAS_W / CANVAS_H, 0.1, 1000);
            studioCamera.position.set(20, 10, 20);
            studioCamera.lookAt(0, 0, 0);

            studioRenderer = new THREE.WebGLRenderer({ antialias: true });
            studioRenderer.setSize(CANVAS_W, CANVAS_H);
            
            const container = document.getElementById('studioCanvasContainer');
            while (container.firstChild) { container.removeChild(container.firstChild); }
            container.appendChild(studioRenderer.domElement);

            studioScene.add(new THREE.AmbientLight(0x404040)); 
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(10, 10, 5);
            studioScene.add(directionalLight);
            
            transformControlsGroup = new THREE.Group();
            transformControlsGroup.visible = false;
            studioScene.add(transformControlsGroup);

            setupStudioControls(studioRenderer.domElement);
        }
        
        function addBlock(x, y, z, w = 4, h = 4, d = 4, color = 0x228B22) {
            if (!studioScene) return; 
            
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshLambertMaterial({ color: color });
            const block = new THREE.Mesh(geometry, material);
            
            block.position.set(x, y, z);
            block.scale.set(w, h, d);
            
            block.userData = { isBlock: true, id: Date.now() }; 
            studioScene.add(block); 
        }
        
        function createBlocksFromData(scene, data, isStudio) {
            clearScene(scene); 
            data.forEach(d => {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: 0x228B22 });
                const block = new THREE.Mesh(geometry, material);
                
                block.position.set(d.x, d.y, d.z);
                block.scale.set(d.w, d.h, d.d);

                block.userData = { isBlock: true, id: Date.now() }; 
                scene.add(block);
            });
        }
        
        // --- HANDLE YARDIMCI FONKSÄ°YONLARI ---

        // TaÅŸÄ±ma (N) Oku
        function createArrow(axis, color) {
            const dir = new THREE.Vector3();
            if (axis === 'x') dir.set(1, 0, 0);
            if (axis === 'y') dir.set(0, 1, 0);
            if (axis === 'z') dir.set(0, 0, 1);

            const arrow = new THREE.ArrowHelper(dir, new THREE.Vector3(0, 0, 0), ARROW_LENGTH, color, 1.5, 1);
            
            // Ok ucunu seÃ§ilebilir yapmak iÃ§in ArrowHelper'Ä±n iÃ§indeki Cone Mesh'i kullanÄ±yoruz.
            // ArrowHelper bir grup, iÃ§indeki mesh'i alÄ±p userdata'ya eklememiz gerek.
            const cone = arrow.children[0]; 

            arrow.userData = { isHandle: true, axis: axis, mode: 'move', color: color };
            cone.userData = arrow.userData; // Raycasting iÃ§in Cone'a da aynÄ± veriyi ekle

            return arrow;
        }

        // BoyutlandÄ±rma (B) KÃ¼resi
        function createResizeSphere(pos, axis, dir, color, mesh) {
            const handleGeometry = new THREE.SphereGeometry(HANDLE_SIZE, 12, 12);
            const handleMaterial = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
            const handle = new THREE.Mesh(handleGeometry, handleMaterial);
            handle.position.copy(pos);
            handle.userData = { 
                isHandle: true, 
                axis: axis, 
                direction: dir, // +1 veya -1
                mode: 'resize',
                parentMesh: mesh 
            };
            return handle;
        }

        // DÃ¶ndÃ¼rme (O) Torus
        function createRotationTorus(axis, color) {
            const torusGeometry = new THREE.TorusGeometry(8, 0.2, 8, 50);
            const handle = new THREE.Mesh(torusGeometry, new THREE.MeshBasicMaterial({ color: color, wireframe: true }));
            handle.userData = { isHandle: true, axis: axis, mode: 'rotate' };
            
            if (axis === 'x') handle.rotation.z = Math.PI / 2;
            if (axis === 'z') handle.rotation.x = Math.PI / 2;
            
            return handle;
        }


        // --- HANDLE OLUÅTURMA MANTIÄI ---

        function attachHandles(mesh) {
            if (!transformControlsGroup) return;

            // 1. Ã–nceki handle'larÄ± temizle
            clearScene(transformControlsGroup);
            transformControlsGroup.visible = false;
            
            if (!mesh) return;
            
            // 2. BloÄŸun pozisyon ve rotasyonunu Handle grubuna kopyala
            transformControlsGroup.position.copy(mesh.position);
            transformControlsGroup.rotation.copy(mesh.rotation);
            const scale = mesh.scale;
            
            if (studioMode === 'move') {
                // TaÅŸÄ±ma Modu (N)
                transformControlsGroup.add(createArrow('x', 0xff0000));
                transformControlsGroup.add(createArrow('y', 0x00ff00));
                transformControlsGroup.add(createArrow('z', 0x0000ff));
                
            } else if (studioMode === 'resize') {
                // BoyutlandÄ±rma Modu (B)
                const handlePositions = [
                    // X Ekseni (KÄ±rmÄ±zÄ±)
                    { axis: 'x', dir: 1, pos: new THREE.Vector3(scale.x / 2, 0, 0), color: 0xff0000 }, 
                    { axis: 'x', dir: -1, pos: new THREE.Vector3(-scale.x / 2, 0, 0), color: 0xff0000 }, 
                    // Y Ekseni (YeÅŸil)
                    { axis: 'y', dir: 1, pos: new THREE.Vector3(0, scale.y / 2, 0), color: 0x00ff00 }, 
                    { axis: 'y', dir: -1, pos: new THREE.Vector3(0, -scale.y / 2, 0), color: 0x00ff00 }, 
                    // Z Ekseni (Mavi)
                    { axis: 'z', dir: 1, pos: new THREE.Vector3(0, 0, scale.z / 2), color: 0x0000ff }, 
                    { axis: 'z', dir: -1, pos: new THREE.Vector3(0, 0, -scale.z / 2), color: 0x0000ff } 
                ];

                handlePositions.forEach(h => {
                    const handle = createResizeSphere(h.pos, h.axis, h.dir, h.color, mesh);
                    transformControlsGroup.add(handle);
                });
                
            } else if (studioMode === 'rotate') {
                // DÃ¶ndÃ¼rme Modu (O)
                transformControlsGroup.add(createRotationTorus('x', 0xff0000));
                transformControlsGroup.add(createRotationTorus('y', 0x00ff00));
                transformControlsGroup.add(createRotationTorus('z', 0x0000ff));
            }

            transformControlsGroup.visible = true;
        }


        // --- 3. KAMERA VE MANÄ°PÃœLASYON KONTROLLERÄ° ---

        let rotationX = 0;
        let rotationY = 0;
        const moveSpeed = 0.5;
        const rotateSpeed = 0.005;

        function setupStudioControls(domElement) {
            window.addEventListener('keydown', (e) => { 
                keys[e.key.toLowerCase()] = true; 
                
                // Mod deÄŸiÅŸimleri
                const newMode = e.key.toLowerCase();
                if (newMode === 'n' || newMode === 'b' || newMode === 'o') {
                    studioMode = newMode;
                    updateToolbarInfo();
                    // Yeni moda gÃ¶re handle'larÄ± gÃ¼ncelle
                    if (selectedMesh) {
                        attachHandles(selectedMesh);
                    } else {
                        attachHandles(null);
                    }
                }
            });
            window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
            
            domElement.addEventListener('mousedown', onMouseDown);
            domElement.addEventListener('mousemove', onMouseMove);
            domElement.addEventListener('mouseup', onMouseUp);
            domElement.addEventListener('mouseleave', onMouseUp); 
        }

        function onMouseDown(e) {
            if (e.button !== 0 || !studioScene) return;

            mouse.x = (e.offsetX / CANVAS_W) * 2 - 1;
            mouse.y = -(e.offsetY / CANVAS_H) * 2 + 1;
            raycaster.setFromCamera(mouse, studioCamera);
            
            // 1. Handle SeÃ§imi (TaÅŸÄ±ma, BoyutlandÄ±rma, DÃ¶ndÃ¼rme)
            if (transformControlsGroup.visible) {
                // Handle'lar bir grup iÃ§inde olduÄŸu iÃ§in recursive true olmalÄ±
                const intersectsHandle = raycaster.intersectObjects(transformControlsGroup.children, true); 
                
                // Sadece mevcut moddaki handle'larÄ± seÃ§
                let foundHandle = intersectsHandle.find(i => {
                    const obj = i.object;
                    // ArrowHelper iÃ§indeki Cone'a tÄ±klanmÄ±ÅŸsa, ArrowHelper'Ä±n kendisini al
                    const handle = obj.userData.isHandle ? obj : obj.parent.userData.isHandle ? obj.parent : null;
                    return handle && handle.userData.mode === studioMode;
                });
                
                if (foundHandle) {
                    selectedHandle = foundHandle.object.userData.isHandle ? foundHandle.object : foundHandle.object.parent;
                    
                    // selectedMesh'i atama (Handle'a tÄ±klayÄ±nca zaten seÃ§ili olmalÄ±, ancak emin olmak iÃ§in)
                    if (selectedHandle.userData.mode === 'resize') {
                        selectedMesh = selectedHandle.userData.parentMesh; 
                    } 
                    
                    // TaÅŸÄ±ma/BoyutlandÄ±rma iÃ§in baÅŸlangÄ±Ã§ Ray kesiÅŸim noktasÄ±nÄ± kaydet
                    selectedHandle.userData.dragStartPoint = foundHandle.point.clone();
                    
                    mouseLook = false; 
                    return; 
                }
            }

            // Ã–nceki seÃ§imi temizle
            if (selectedMesh) selectedMesh.material.color.set(0x228B22);
            selectedHandle = null;
            
            // 2. Blok SeÃ§imi (Handle seÃ§ilemediyse)
            const intersectsBlock = raycaster.intersectObjects(studioScene.children.filter(c => c.userData.isBlock));

            if (intersectsBlock.length > 0) {
                selectedMesh = intersectsBlock[0].object;
                selectedMesh.material.color.set(0xffa500); 
                
                attachHandles(selectedMesh);
                updateToolbarInfo();
                
                mouseLook = false; 
                
                if (studioMode === 'move') {
                    // Blok TaÅŸÄ±ma iÃ§in offset hesapla (Handle'a tÄ±klanmadÄ±ysa XZ serbest taÅŸÄ±ma iÃ§in)
                    dragOffset.subVectors(selectedMesh.position, intersectsBlock[0].point);
                }
                
            } else {
                // HiÃ§bir ÅŸey seÃ§ilmedi, kamera dÃ¶ndÃ¼rme moduna gir
                selectedMesh = null;
                attachHandles(null);
                updateToolbarInfo();
                mouseLook = true;
                rotationX = e.clientX;
                rotationY = e.clientY;
            }
        }

        function onMouseMove(e) {
            mouse.x = (e.offsetX / CANVAS_W) * 2 - 1;
            mouse.y = -(e.offsetY / CANVAS_H) * 2 + 1;

            if (mouseLook) {
                // Kamera DÃ¶ndÃ¼rme
                const deltaX = e.clientX - rotationX;
                const deltaY = e.clientY - rotationY;
                
                studioCamera.rotation.y -= deltaX * rotateSpeed;
                studioCamera.rotation.x -= deltaY * rotateSpeed;
                studioCamera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, studioCamera.rotation.x));

                rotationX = e.clientX;
                rotationY = e.clientY;
            } else if (selectedHandle) {
                // Handle SÃ¼rÃ¼kleme MantÄ±ÄŸÄ± (N, B, O)
                
                raycaster.setFromCamera(mouse, studioCamera);
                const mesh = selectedMesh;
                const axis = selectedHandle.userData.axis;
                
                if (studioMode === 'resize') {
                    // BoyutlandÄ±rma (B Modu)
                    const direction = selectedHandle.userData.direction;
                    
                    // X, Y, Z eksenine dik dÃ¼zlemi oluÅŸtur
                    let plane;
                    if (axis === 'x') plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), -mesh.position.z);
                    if (axis === 'y') plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -mesh.position.y);
                    if (axis === 'z') plane = new THREE.Plane(new THREE.Vector3(1, 0, 0), -mesh.position.x);

                    const intersectPoint = new THREE.Vector3();
                    raycaster.ray.intersectPlane(plane, intersectPoint);
                    
                    if (intersectPoint) {
                        let newIntersectionPoint = intersectPoint[axis];
                        
                        // Sabit kalmasÄ± gereken karÅŸÄ± yÃ¼zeyin pozisyonu
                        const fixedSurfacePos = mesh.position[axis] - (mesh.scale[axis] * direction) / 2;
                        
                        let newDimension = Math.abs(newIntersectionPoint - fixedSurfacePos);
                        newDimension = Math.max(0.5, newDimension); // Min 0.5

                        const oldDimension = mesh.scale[axis];
                        const delta = newDimension - oldDimension;
                        
                        if (Math.abs(delta) > 0.01) {
                            mesh.scale[axis] = newDimension;
                            
                            // YÃ¼kseklik deÄŸiÅŸirken bloÄŸun zemine yapÄ±ÅŸÄ±k kalmasÄ± iÃ§in
                            // Y ekseninde (boyutlandÄ±rma) pozisyonu yarÄ± delta kadar kaydÄ±r
                            mesh.position[axis] += (delta / 2) * direction;

                            attachHandles(mesh); // Handle'larÄ± yeniden konumlandÄ±r
                        }
                    }

                } else if (studioMode === 'move') {
                    // TaÅŸÄ±ma (N Modu) - Ok iÅŸaretleri boyunca taÅŸÄ±ma
                    
                    // TaÅŸÄ±ma dÃ¼zlemi: Kamera bakÄ±ÅŸ aÃ§Ä±sÄ±na en dik ve handle'Ä±n baÅŸladÄ±ÄŸÄ± noktadan geÃ§en dÃ¼zlem
                    const startPoint = selectedHandle.userData.dragStartPoint;
                    
                    let planeNormal = new THREE.Vector3();
                    let camDirection = new THREE.Vector3();
                    studioCamera.getWorldDirection(camDirection);
                    
                    // TaÅŸÄ±ma eksenine dik olan ve kameraya bakan bir vektÃ¶r oluÅŸtur
                    if (axis === 'x') planeNormal.set(0, camDirection.y, camDirection.z);
                    if (axis === 'y') planeNormal.set(camDirection.x, 0, camDirection.z);
                    if (axis === 'z') planeNormal.set(camDirection.x, camDirection.y, 0);
                    planeNormal.normalize();
                    
                    const plane = new THREE.Plane(planeNormal, -startPoint.dot(planeNormal));
                    const intersectPoint = new THREE.Vector3();
                    raycaster.ray.intersectPlane(plane, intersectPoint);

                    if (intersectPoint) {
                        // KesiÅŸim noktasÄ±ndan baÅŸlangÄ±Ã§ noktasÄ±nÄ± Ã§Ä±kar (delta vektÃ¶rÃ¼)
                        const delta = new THREE.Vector3().subVectors(intersectPoint, startPoint);

                        // Delta vektÃ¶rÃ¼nÃ¼ sadece seÃ§ilen eksen Ã¼zerinde kullan
                        if (axis === 'x') mesh.position.x += delta.x;
                        if (axis === 'y') mesh.position.y += delta.y;
                        if (axis === 'z') mesh.position.z += delta.z;
                        
                        // Yeni baÅŸlangÄ±Ã§ noktasÄ± olarak kesiÅŸim noktasÄ±nÄ± kaydet
                        selectedHandle.userData.dragStartPoint.copy(intersectPoint);
                        
                        // Handle'larÄ± bloÄŸa taÅŸÄ±
                        attachHandles(mesh);
                    }
                }
                
            } else if (selectedMesh && studioMode === 'move') {
                // Blok TaÅŸÄ±ma (N Modu - Handle yerine bloÄŸa tÄ±klama)
                // Bu, XZ serbest taÅŸÄ±ma olmalÄ±dÄ±r
                raycaster.setFromCamera(mouse, studioCamera);
                
                const planeY = selectedMesh.position.y;
                const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), -planeY);
                const intersectPoint = new THREE.Vector3();
                raycaster.ray.intersectPlane(plane, intersectPoint);

                if (intersectPoint) {
                    selectedMesh.position.x = intersectPoint.x + dragOffset.x;
                    selectedMesh.position.z = intersectPoint.z + dragOffset.z;
                    // Handle'larÄ± da bloÄŸa taÅŸÄ± (gÃ¶rÃ¼nseler bile pozisyonu senkronize et)
                    if (transformControlsGroup.visible) {
                        transformControlsGroup.position.copy(selectedMesh.position);
                    }
                }
            }
        }

        function onMouseUp() {
            mouseLook = false;
            if (selectedHandle) {
                // SÃ¼rÃ¼kleme bitince handle'Ä± bÄ±rak
                selectedHandle = null;
            }
        }

        function updateCamera() {
            const direction = new THREE.Vector3();
            studioCamera.getWorldDirection(direction);

            let moveVector = new THREE.Vector3(0, 0, 0);

            if (keys['w']) moveVector.z -= 1;
            if (keys['s']) moveVector.z += 1;
            if (keys['a']) moveVector.x -= 1;
            if (keys['d']) moveVector.x += 1;
            
            if (keys['q']) studioCamera.position.y -= moveSpeed; 
            if (keys['e']) studioCamera.position.y += moveSpeed; 

            if (moveVector.lengthSq() > 0) {
                moveVector.normalize().multiplyScalar(moveSpeed);
                
                const forward = direction.clone();
                forward.y = 0; 
                forward.normalize();
                studioCamera.position.addScaledVector(forward, -moveVector.z);

                const right = new THREE.Vector3().crossVectors(studioCamera.up, forward).normalize();
                studioCamera.position.addScaledVector(right, moveVector.x);
            }
        }

        // --- 4. 3D STUDIO DÃ–NGÃœSÃœ ---

        function animateStudio() {
            updateCamera();
            studioRenderer.render(studioScene, studioCamera);
            studioAnimationFrame = requestAnimationFrame(animateStudio);
        }

        function startStudioLoop() {
             if (studioAnimationFrame) cancelAnimationFrame(studioAnimationFrame);
             animateStudio();
        }

        function stopStudioLoop() {
            if (studioAnimationFrame) cancelAnimationFrame(studioAnimationFrame);
            studioAnimationFrame = null;
        }

        // --- 5. OYUN CLIENT MANTIÄI (WASD + SPACE) ---
        
        function setupGame3D() {
            gameScene = new THREE.Scene();
            gameScene.background = new THREE.Color(0x87ceeb);

            gameCamera = new THREE.PerspectiveCamera(75, CANVAS_W / CANVAS_H, 0.1, 1000);
            
            gameScene.add(new THREE.AmbientLight(0x404040));
            gameScene.add(new THREE.DirectionalLight(0xffffff, 0.8));

            gameRenderer = new THREE.WebGLRenderer({ antialias: true });
            gameRenderer.setSize(CANVAS_W, CANVAS_H);

            const container = document.getElementById('gameCanvasContainer');
            while (container.firstChild) { container.removeChild(container.firstChild); }
            container.appendChild(gameRenderer.domElement);
            
            createBlocksFromData(gameScene, mapDataJSON, false);

            const playerGeo = new THREE.CylinderGeometry(PLAYER_RADIUS, PLAYER_RADIUS, PLAYER_HEIGHT, 16);
            const playerMat = new THREE.MeshLambertMaterial({ color: 0xff0000 });
            playerMesh = new THREE.Mesh(playerGeo, playerMat);
            playerMesh.position.set(0, PLAYER_HEIGHT / 2 + 1, 0); 
            gameScene.add(playerMesh);

            playerMesh.userData = {
                velX: 0, velY: 0, velZ: 0, onGround: false
            };
            
            window.addEventListener('keydown', (e) => { 
                keys[e.key.toLowerCase()] = true; 
                if (e.key === ' ' && playerMesh && playerMesh.userData.onGround) {
                    playerMesh.userData.velY = JUMP_FORCE; 
                    playerMesh.userData.onGround = false;
                }
            });
            window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
        }

        function updateGame() {
            if (!playerMesh) return;
            
            let userData = playerMesh.userData;
            let currentPos = playerMesh.position;
            
            let moveVector = new THREE.Vector3(0, 0, 0);
            if (keys['w']) moveVector.z -= 1;
            if (keys['s']) moveVector.z += 1;
            if (keys['a']) moveVector.x -= 1;
            if (keys['d']) moveVector.x += 1;
            
            if (moveVector.lengthSq() > 0) {
                moveVector.normalize().multiplyScalar(MOVE_SPEED);
                currentPos.x -= moveVector.x;
                currentPos.z -= moveVector.z;
            }

            userData.velY -= GRAVITY;
            currentPos.y += userData.velY;
            userData.onGround = false;

            // Basit Ã‡arpÄ±ÅŸma KontrolÃ¼ (Zemin)
            gameScene.children.forEach(mesh => {
                if (mesh.userData.isBlock) {
                    if (userData.velY < 0 && 
                        currentPos.x > mesh.position.x - mesh.scale.x / 2 && currentPos.x < mesh.position.x + mesh.scale.x / 2 &&
                        currentPos.z > mesh.position.z - mesh.scale.z / 2 && currentPos.z < mesh.position.z + mesh.scale.z / 2) {
                        
                        const floorY = mesh.position.y + mesh.scale.y / 2;
                        
                        if (currentPos.y - PLAYER_HEIGHT / 2 < floorY) {
                            currentPos.y = floorY + PLAYER_HEIGHT / 2; 
                            userData.velY = 0;
                            userData.onGround = true;
                        }
                    }
                }
            });

            // Kamera Takibi
            gameCamera.position.set(currentPos.x, currentPos.y + 5, currentPos.z + 10);
            gameCamera.lookAt(currentPos.x, currentPos.y, currentPos.z);
        }

        function drawGame() {
            gameRenderer.render(gameScene, gameCamera);
        }

        function gameLoop() {
            updateGame();
            drawGame();
            gameAnimationFrame = requestAnimationFrame(gameLoop);
        }
        
        function startGameLoop() {
             if (gameAnimationFrame) cancelAnimationFrame(gameAnimationFrame);
             gameLoop();
        }

        function stopGameLoop() {
            if (gameAnimationFrame) cancelAnimationFrame(gameAnimationFrame);
            gameAnimationFrame = null;
            playerMesh = null;
        }
        
        // --- UYGULAMA BAÅLANGICI ---
        window.onload = () => {
            showScreen('homeScreen'); 
        };
    </script>
</body>
</html>
